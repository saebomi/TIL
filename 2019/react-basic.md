## 리액트 기초공부

### JSX
- 태그는 꼭 닫혀있어야 함
- Self Closing 태그 - 태그와 태그 사이에 내용이 들어가지 않을 때 사용
- 두 개 이상의 태그는 무조건 하나의 태그로 감싸져있어야 함
- JSX 안에 자바스크립트 값 사용하기 - '{}' 으로 감싸서 보여줌
- style과 className - 인라인스타일은 객체형태로 작성, camelCase 형태로 네이밍해주어야 함
- 주석 - {/* 이런 형태로 */} 작성, 열리는 태그 내부에서는 // 이런형태로도 주석 작성이 가능

### props 를 통해 컴포넌트에게 값 전달하기
- props(properties) - 파라미터를 통하여 조회가능 ex) name 값 조회 시 > props.name을 조회
- 여러 개의 props, 비구조화 할당
- defaultProps - 컴포넌트에 props를 지정하지 않았을 때 기본적으로 사용할 값 설정
- props.children - 컴포넌트 태그 사이에 넣은 값을 조회하고 싶을 때 사용

### 조건부 렌더링
- 조건부 렌더링 : 특정 조건에 따라 다른 결과물을 렌더링하는 것
- 보통 삼항연산자를 사용한 조건부 렌더링 -  주로 특정 조건에 따라 보여줘야 하는 내용이 다를 때 사용
- props 값 설정 생략 시 > true로 설정한 것으로 간주

### useState를 통해 컴포넌트에서 바뀌는 값 관리하기
- 엘리먼트에 이벤트를 설정해줄 때 > on이벤트이름={실행하고싶은함수} 형태
- useState 함수 - 컴포넌트에서 상태관리 가능
- 함수형 업데이트 - 나중에 컴포넌트를 최적화하게 될 때 사용

### input 상태 관리하기
- input 상태 관리 - input 태그의 value 값도 설정해줘야 상태가 바뀌었을 때 input의 내용도 업데이트됨

### 여러 개의 input 상태 관리하기
- 리액트에서 객체 수정 시 - 새로운 객체를 만들어서 새로운 객체에 변화를 주고, 이를 상태로 이용해야 함 <br>
  - ...문법 : spread 문법, "불변성을 지킨다"

### useRef 로 특정 DOM 선택하기
- ref - 사용할 때에는 useRef 라는 Hook 함수를 사용
- useRef() - Ref 객체를 만들고, 이 객체를 우리가 선택하고 싶은 DOM에 ref 값으로 설정해주어야 함

### 배열 렌더링하기
- 내장함수 map() - 동적인 배열을 렌더링해야할 때 사용, 배열안에 있는 각 원소를 변환하여 새로운 배열을 만들어줌
- 리액트에서 배열을 렌더링할 때 key 라는 props 를 설정해야 함

### useRef 로 컴포넌트 안의 변수 만들기
- useRef 를 사용하여 다음과 같은 값 관리할 수 있음<br>
  - setTimeout, setInterval 을 통해서 만들어진 id<br>
  - 외부 라이브러리를 사용하여 생성된 인스턴스<br>
  - scroll 위치<br>

### 배열에 항목 추가하기
- 배열에 변화를 줄 때 > 불변성을 지켜주어야 함<br>
  - spread 연산자 사용 <br>
  - concat 함수 사용<br>

### 배열에 항목 제거하기
- 불변성을 지키면서 특정 원소를 배열에서 제거 > filter 배열 내장 함수를 사용하는 것이 가장 편함
- filter 함수 > 배열에서 특정 조건이 만족하는 원소들만 추출하여 새로운 배열을 만들어줌

### 배열 항목 수정하기
- onToggle 

### useEffect를 사용하여 마운트/언마운트/업데이트시 할 작업 설정하기
- useEffect를 사용할 때 > 첫번째 파라미터에는 함수, 두번째 파라미터에는 의존값이 들어있는 배열 (deps)을 넣는다.
- cleanup 함수 > useEffect 에 대한 뒷정리를 해줌
- 마운트 시에 하는 작업 <br>
  - props 로 받은 값을 컴포넌트의 로컬 상태로 설정 <br>
  - 외부 API 요청(REST API 등) <br>
  - 라이브러리 사용(D3, Video.js 등) <br>
  - setInterval, setTimeout 을 사용하여 등록한 작업들 clear하기<br>
- 언마운트 시 하는 작업 <br>
  - setInterval, setTimeout을 사용하여 등록한 작업들 clear하기 <br>
  - 라이브러리 인스턴스 제거 <br>
- useEffect 안에서 사용하는 상태 또는 props가 있다면, useEffect의 deps에 넣어주어야 하는게 규칙<br>
  - 그렇지 않으면 useEffect에 등록한 함수가 실행될 때 최신 props/상태를 가르키지 않음

### useMemo 를 사용하여 연산한 값 재사용하기
- useMemo <br>
  - Hook 함수로, 성능을 최적화할 수 있음 <br>
  - 특정 결과값을 재사용할 때 사용

### useCallback 을 사용하여 함수 재사용하기
- useCallback <br>
  - 특정 함수를 새로 만들지 않고 재사용하고 싶을때 사용

### React.memo 를 사용한 컴포넌트 리렌더링 방지
- 컴포넌트에서 리렌더링이 필요한 상황에서만 리렌더링을 하도록 설정
- useCallback, useMemo, React.memo는 컴포넌트의 성능을 실제로 개선할 수 있는 상황에서만..

### useReducer 를 사용하여 상태 업데이트 로직 분리하기
- 컴포넌트의 상태 업데이트 로직을 컴포넌트에서 분리 가능
- useReducer <br>
  - 현재 상태와 액션 객체를 파라미터로 받아와서 새로운 상태를 반환해주는 함수<br>
  - > function reducer(state, action) {<br>
  // 새로운 상태를 만드는 로직<br>
  // const nextState = ...<br>
  return nextState; }<br>

### 커스텀 Hooks 만들기
- 커스텀 Hook을 만들어서 사용하면 컴포넌트의 로직을 분리시켜서 필요할 때 쉽게 재사용 가능

